{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/home/ugaly/Desktop/semister 2/react-scheduler-demo-standard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _objectSpread = require(\"/home/ugaly/Desktop/semister 2/react-scheduler-demo-standard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _toConsumableArray = require(\"/home/ugaly/Desktop/semister 2/react-scheduler-demo-standard/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar constants = require('./constants');\nvar utils = require('./utils');\n\n/**\n * Constants\n */\n\nvar MAX_LENGTH = constants.MAX_LENGTH,\n  POSIX_REGEX_SOURCE = constants.POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS = constants.REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF = constants.REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS = constants.REPLACEMENTS;\n\n/**\n * Helpers\n */\n\nvar expandRange = function expandRange(args, options) {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange.apply(options, _toConsumableArray(args).concat([options]));\n  }\n  args.sort();\n  var value = \"[\".concat(args.join('-'), \"]\");\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(function (v) {\n      return utils.escapeRegex(v);\n    }).join('..');\n  }\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nvar syntaxError = function syntaxError(type, char) {\n  return \"Missing \".concat(type, \": \\\"\").concat(char, \"\\\" - use \\\"\\\\\\\\\").concat(char, \"\\\" to match literal characters\");\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nvar parse = function parse(input, options) {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  input = REPLACEMENTS[input] || input;\n  var opts = _objectSpread({}, options);\n  var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  var len = input.length;\n  if (len > max) {\n    throw new SyntaxError(\"Input length: \".concat(len, \", exceeds maximum allowed length: \").concat(max));\n  }\n  var bos = {\n    type: 'bos',\n    value: '',\n    output: opts.prepend || ''\n  };\n  var tokens = [bos];\n  var capture = opts.capture ? '' : '?:';\n  var win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  var PLATFORM_CHARS = constants.globChars(win32);\n  var EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n  var DOT_LITERAL = PLATFORM_CHARS.DOT_LITERAL,\n    PLUS_LITERAL = PLATFORM_CHARS.PLUS_LITERAL,\n    SLASH_LITERAL = PLATFORM_CHARS.SLASH_LITERAL,\n    ONE_CHAR = PLATFORM_CHARS.ONE_CHAR,\n    DOTS_SLASH = PLATFORM_CHARS.DOTS_SLASH,\n    NO_DOT = PLATFORM_CHARS.NO_DOT,\n    NO_DOT_SLASH = PLATFORM_CHARS.NO_DOT_SLASH,\n    NO_DOTS_SLASH = PLATFORM_CHARS.NO_DOTS_SLASH,\n    QMARK = PLATFORM_CHARS.QMARK,\n    QMARK_NO_DOT = PLATFORM_CHARS.QMARK_NO_DOT,\n    STAR = PLATFORM_CHARS.STAR,\n    START_ANCHOR = PLATFORM_CHARS.START_ANCHOR;\n  var globstar = function globstar(opts) {\n    return \"(\".concat(capture, \"(?:(?!\").concat(START_ANCHOR).concat(opts.dot ? DOTS_SLASH : DOT_LITERAL, \").)*?)\");\n  };\n  var nodot = opts.dot ? '' : NO_DOT;\n  var qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  var star = opts.bash === true ? globstar(opts) : STAR;\n  if (opts.capture) {\n    star = \"(\".concat(star, \")\");\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n  var state = {\n    input: input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens: tokens\n  };\n  input = utils.removePrefix(input, state);\n  len = input.length;\n  var extglobs = [];\n  var braces = [];\n  var stack = [];\n  var prev = bos;\n  var value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  var eos = function eos() {\n    return state.index === len - 1;\n  };\n  var peek = state.peek = function () {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return input[state.index + n];\n  };\n  var advance = state.advance = function () {\n    return input[++state.index] || '';\n  };\n  var remaining = function remaining() {\n    return input.slice(state.index + 1);\n  };\n  var consume = function consume() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var num = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    state.consumed += value;\n    state.index += num;\n  };\n  var append = function append(token) {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n  var negate = function negate() {\n    var count = 1;\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n    if (count % 2 === 0) {\n      return false;\n    }\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n  var increment = function increment(type) {\n    state[type]++;\n    stack.push(type);\n  };\n  var decrement = function decrement(type) {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  var push = function push(tok) {\n    if (prev.type === 'globstar') {\n      var isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      var isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n  var extglobOpen = function extglobOpen(type, value) {\n    var token = _objectSpread(_objectSpread({}, EXTGLOB_CHARS[value]), {}, {\n      conditions: 1,\n      inner: ''\n    });\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    var output = (opts.capture ? '(' : '') + token.open;\n    increment('parens');\n    push({\n      type: type,\n      value: value,\n      output: state.output ? '' : ONE_CHAR\n    });\n    push({\n      type: 'paren',\n      extglob: true,\n      value: advance(),\n      output: output\n    });\n    extglobs.push(token);\n  };\n  var extglobClose = function extglobClose(token) {\n    var output = token.close + (opts.capture ? ')' : '');\n    var rest;\n    if (token.type === 'negate') {\n      var extglobStar = star;\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = \")$))\".concat(extglobStar);\n      }\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        var expression = parse(rest, _objectSpread(_objectSpread({}, options), {}, {\n          fastpaths: false\n        })).output;\n        output = token.close = \")\".concat(expression, \")\").concat(extglobStar, \")\");\n      }\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n    push({\n      type: 'paren',\n      extglob: true,\n      value: value,\n      output: output\n    });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    var backslashes = false;\n    var output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, function (m, esc, chars, first, rest, index) {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : \"\\\\\".concat(m);\n    });\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, function (m) {\n          return m.length % 2 === 0 ? '\\\\\\\\' : m ? '\\\\' : '';\n        });\n      }\n    }\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n    if (value === \"\\0\") {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      var next = peek();\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n      if (next === '.' || next === ';') {\n        continue;\n      }\n      if (!next) {\n        value += '\\\\';\n        push({\n          type: 'text',\n          value: value\n        });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      var match = /^\\\\+/.exec(remaining());\n      var slashes = 0;\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n      if (state.brackets === 0) {\n        push({\n          type: 'text',\n          value: value\n        });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        var inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n          if (inner.includes(':')) {\n            var idx = prev.value.lastIndexOf('[');\n            var pre = prev.value.slice(0, idx);\n            var _rest = prev.value.slice(idx + 2);\n            var posix = POSIX_REGEX_SOURCE[_rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n      if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {\n        value = \"\\\\\".concat(value);\n      }\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = \"\\\\\".concat(value);\n      }\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n      prev.value += value;\n      append({\n        value: value\n      });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({\n        value: value\n      });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({\n          type: 'text',\n          value: value\n        });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({\n        type: 'paren',\n        value: value\n      });\n      continue;\n    }\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n      var extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n      push({\n        type: 'paren',\n        value: value,\n        output: state.parens ? ')' : '\\\\)'\n      });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n        value = \"\\\\\".concat(value);\n      } else {\n        increment('brackets');\n      }\n      push({\n        type: 'bracket',\n        value: value\n      });\n      continue;\n    }\n    if (value === ']') {\n      if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {\n        push({\n          type: 'text',\n          value: value,\n          output: \"\\\\\".concat(value)\n        });\n        continue;\n      }\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n        push({\n          type: 'text',\n          value: value,\n          output: \"\\\\\".concat(value)\n        });\n        continue;\n      }\n      decrement('brackets');\n      var prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = \"/\".concat(value);\n      }\n      prev.value += value;\n      append({\n        value: value\n      });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n      var escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = \"(\".concat(capture).concat(escaped, \"|\").concat(prev.value, \")\");\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n      var open = {\n        type: 'brace',\n        value: value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n      braces.push(open);\n      push(open);\n      continue;\n    }\n    if (value === '}') {\n      var brace = braces[braces.length - 1];\n      if (opts.nobrace === true || !brace) {\n        push({\n          type: 'text',\n          value: value,\n          output: value\n        });\n        continue;\n      }\n      var _output = ')';\n      if (brace.dots === true) {\n        var arr = tokens.slice();\n        var range = [];\n        for (var i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n        _output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n      if (brace.comma !== true && brace.dots !== true) {\n        var out = state.output.slice(0, brace.outputIndex);\n        var toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = _output = '\\\\}';\n        state.output = out;\n        var _iterator = _createForOfIteratorHelper(toks),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var t = _step.value;\n            state.output += t.output || t.value;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      push({\n        type: 'brace',\n        value: value,\n        output: _output\n      });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({\n        type: 'text',\n        value: value\n      });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      var _output2 = value;\n      var _brace = braces[braces.length - 1];\n      if (_brace && stack[stack.length - 1] === 'braces') {\n        _brace.comma = true;\n        _output2 = '|';\n      }\n      push({\n        type: 'comma',\n        value: value,\n        output: _output2\n      });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n      push({\n        type: 'slash',\n        value: value,\n        output: SLASH_LITERAL\n      });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        var _brace2 = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        _brace2.dots = true;\n        continue;\n      }\n      if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({\n          type: 'text',\n          value: value,\n          output: DOT_LITERAL\n        });\n        continue;\n      }\n      push({\n        type: 'dot',\n        value: value,\n        output: DOT_LITERAL\n      });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      var isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n      if (prev && prev.type === 'paren') {\n        var _next = peek();\n        var _output3 = value;\n        if (_next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n        if (prev.value === '(' && !/[!=<:]/.test(_next) || _next === '<' && !/<([!=]|\\w+>)/.test(remaining())) {\n          _output3 = \"\\\\\".concat(value);\n        }\n        push({\n          type: 'text',\n          value: value,\n          output: _output3\n        });\n        continue;\n      }\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({\n          type: 'qmark',\n          value: value,\n          output: QMARK_NO_DOT\n        });\n        continue;\n      }\n      push({\n        type: 'qmark',\n        value: value,\n        output: QMARK\n      });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n      if (prev && prev.value === '(' || opts.regex === false) {\n        push({\n          type: 'plus',\n          value: value,\n          output: PLUS_LITERAL\n        });\n        continue;\n      }\n      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {\n        push({\n          type: 'plus',\n          value: value\n        });\n        continue;\n      }\n      push({\n        type: 'plus',\n        value: PLUS_LITERAL\n      });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({\n          type: 'at',\n          extglob: true,\n          value: value,\n          output: ''\n        });\n        continue;\n      }\n      push({\n        type: 'text',\n        value: value\n      });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = \"\\\\\".concat(value);\n      }\n      var _match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (_match) {\n        value += _match[0];\n        state.index += _match[0].length;\n      }\n      push({\n        type: 'text',\n        value: value\n      });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n    var rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n      var prior = prev.prev;\n      var before = prior.prev;\n      var isStart = prior.type === 'slash' || prior.type === 'bos';\n      var afterStar = before && (before.type === 'star' || before.type === 'globstar');\n      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {\n        push({\n          type: 'star',\n          value: value,\n          output: ''\n        });\n        continue;\n      }\n      var isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      var isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({\n          type: 'star',\n          value: value,\n          output: ''\n        });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        var after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = \"(?:\".concat(prior.output);\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        var end = rest[1] !== void 0 ? '|$' : '';\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = \"(?:\".concat(prior.output);\n        prev.type = 'globstar';\n        prev.output = \"\".concat(globstar(opts)).concat(SLASH_LITERAL, \"|\").concat(SLASH_LITERAL).concat(end, \")\");\n        prev.value += value;\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      }\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = \"(?:^|\".concat(SLASH_LITERAL, \"|\").concat(globstar(opts)).concat(SLASH_LITERAL, \")\");\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n    var token = {\n      type: 'star',\n      value: value,\n      output: star\n    };\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n    push(token);\n  }\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({\n      type: 'maybe_slash',\n      value: '',\n      output: \"\".concat(SLASH_LITERAL, \"?\")\n    });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n    var _iterator2 = _createForOfIteratorHelper(state.tokens),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _token = _step2.value;\n        state.output += _token.output != null ? _token.output : _token.value;\n        if (_token.suffix) {\n          state.output += _token.suffix;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = function (input, options) {\n  var opts = _objectSpread({}, options);\n  var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  var len = input.length;\n  if (len > max) {\n    throw new SyntaxError(\"Input length: \".concat(len, \", exceeds maximum allowed length: \").concat(max));\n  }\n  input = REPLACEMENTS[input] || input;\n  var win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  var _constants$globChars = constants.globChars(win32),\n    DOT_LITERAL = _constants$globChars.DOT_LITERAL,\n    SLASH_LITERAL = _constants$globChars.SLASH_LITERAL,\n    ONE_CHAR = _constants$globChars.ONE_CHAR,\n    DOTS_SLASH = _constants$globChars.DOTS_SLASH,\n    NO_DOT = _constants$globChars.NO_DOT,\n    NO_DOTS = _constants$globChars.NO_DOTS,\n    NO_DOTS_SLASH = _constants$globChars.NO_DOTS_SLASH,\n    STAR = _constants$globChars.STAR,\n    START_ANCHOR = _constants$globChars.START_ANCHOR;\n  var nodot = opts.dot ? NO_DOTS : NO_DOT;\n  var slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  var capture = opts.capture ? '' : '?:';\n  var state = {\n    negated: false,\n    prefix: ''\n  };\n  var star = opts.bash === true ? '.*?' : STAR;\n  if (opts.capture) {\n    star = \"(\".concat(star, \")\");\n  }\n  var globstar = function globstar(opts) {\n    if (opts.noglobstar === true) return star;\n    return \"(\".concat(capture, \"(?:(?!\").concat(START_ANCHOR).concat(opts.dot ? DOTS_SLASH : DOT_LITERAL, \").)*?)\");\n  };\n  var create = function create(str) {\n    switch (str) {\n      case '*':\n        return \"\".concat(nodot).concat(ONE_CHAR).concat(star);\n      case '.*':\n        return \"\".concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);\n      case '*.*':\n        return \"\".concat(nodot).concat(star).concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);\n      case '*/*':\n        return \"\".concat(nodot).concat(star).concat(SLASH_LITERAL).concat(ONE_CHAR).concat(slashDot).concat(star);\n      case '**':\n        return nodot + globstar(opts);\n      case '**/*':\n        return \"(?:\".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, \")?\").concat(slashDot).concat(ONE_CHAR).concat(star);\n      case '**/*.*':\n        return \"(?:\".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, \")?\").concat(slashDot).concat(star).concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);\n      case '**/.*':\n        return \"(?:\".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, \")?\").concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);\n      default:\n        {\n          var match = /^(.*?)\\.(\\w+)$/.exec(str);\n          if (!match) return;\n          var _source = create(match[1]);\n          if (!_source) return;\n          return _source + DOT_LITERAL + match[2];\n        }\n    }\n  };\n  var output = utils.removePrefix(input, state);\n  var source = create(output);\n  if (source && opts.strictSlashes !== true) {\n    source += \"\".concat(SLASH_LITERAL, \"?\");\n  }\n  return source;\n};\nmodule.exports = parse;","map":{"version":3,"names":["_createForOfIteratorHelper","require","default","_objectSpread","_toConsumableArray","constants","utils","MAX_LENGTH","POSIX_REGEX_SOURCE","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REPLACEMENTS","expandRange","args","options","apply","concat","sort","value","join","RegExp","ex","map","v","escapeRegex","syntaxError","type","char","parse","input","TypeError","opts","max","maxLength","Math","min","len","length","SyntaxError","bos","output","prepend","tokens","capture","win32","isWindows","PLATFORM_CHARS","globChars","EXTGLOB_CHARS","extglobChars","DOT_LITERAL","PLUS_LITERAL","SLASH_LITERAL","ONE_CHAR","DOTS_SLASH","NO_DOT","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK","QMARK_NO_DOT","STAR","START_ANCHOR","globstar","dot","nodot","qmarkNoDot","star","bash","noext","noextglob","state","index","start","consumed","prefix","backtrack","negated","brackets","braces","parens","quotes","removePrefix","extglobs","stack","prev","eos","peek","n","arguments","undefined","advance","remaining","slice","consume","num","append","token","negate","count","increment","push","decrement","pop","tok","isBrace","isExtglob","extglob","inner","extglobOpen","conditions","open","extglobClose","close","rest","extglobStar","includes","test","expression","fastpaths","negatedExtglob","backslashes","replace","m","esc","chars","first","repeat","unescape","contains","wrapOutput","next","match","exec","slashes","posix","idx","lastIndexOf","pre","indexOf","keepQuotes","strictBrackets","nobracket","prevValue","literalBrackets","hasRegexChars","escaped","nobrace","outputIndex","tokensIndex","brace","dots","arr","range","i","unshift","comma","out","toks","_iterator","_step","s","done","t","err","e","f","isGroup","supportsLookbehinds","Error","nonegate","regex","noglobstar","prior","before","isStart","afterStar","after","strictSlashes","end","escapeLast","_iterator2","_step2","suffix","_constants$globChars","NO_DOTS","slashDot","create","str","source","module","exports"],"sources":["/home/ugaly/Desktop/semister 2/react-scheduler-demo-standard/node_modules/picomatch/lib/parse.js"],"sourcesContent":["'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n"],"mappings":"AAAA,YAAY;;AAAC,IAAAA,0BAAA,GAAAC,OAAA,sKAAAC,OAAA;AAAA,IAAAC,aAAA,GAAAF,OAAA,0JAAAC,OAAA;AAAA,IAAAE,kBAAA,GAAAH,OAAA,8JAAAC,OAAA;AAEb,IAAMG,SAAS,GAAGJ,OAAO,CAAC,aAAa,CAAC;AACxC,IAAMK,KAAK,GAAGL,OAAO,CAAC,SAAS,CAAC;;AAEhC;AACA;AACA;;AAEA,IACEM,UAAU,GAKRF,SAAS,CALXE,UAAU;EACVC,kBAAkB,GAIhBH,SAAS,CAJXG,kBAAkB;EAClBC,uBAAuB,GAGrBJ,SAAS,CAHXI,uBAAuB;EACvBC,2BAA2B,GAEzBL,SAAS,CAFXK,2BAA2B;EAC3BC,YAAY,GACVN,SAAS,CADXM,YAAY;;AAGd;AACA;AACA;;AAEA,IAAMC,WAAW,GAAG,SAAdA,WAAWA,CAAIC,IAAI,EAAEC,OAAO,EAAK;EACrC,IAAI,OAAOA,OAAO,CAACF,WAAW,KAAK,UAAU,EAAE;IAC7C,OAAOE,OAAO,CAACF,WAAW,CAAAG,KAAA,CAAnBD,OAAO,EAAAV,kBAAA,CAAgBS,IAAI,EAAAG,MAAA,EAAEF,OAAO,GAAC;EAC9C;EAEAD,IAAI,CAACI,IAAI,CAAC,CAAC;EACX,IAAMC,KAAK,OAAAF,MAAA,CAAOH,IAAI,CAACM,IAAI,CAAC,GAAG,CAAC,MAAG;EAEnC,IAAI;IACF;IACA,IAAIC,MAAM,CAACF,KAAK,CAAC;EACnB,CAAC,CAAC,OAAOG,EAAE,EAAE;IACX,OAAOR,IAAI,CAACS,GAAG,CAAC,UAAAC,CAAC;MAAA,OAAIjB,KAAK,CAACkB,WAAW,CAACD,CAAC,CAAC;IAAA,EAAC,CAACJ,IAAI,CAAC,IAAI,CAAC;EACvD;EAEA,OAAOD,KAAK;AACd,CAAC;;AAED;AACA;AACA;;AAEA,IAAMO,WAAW,GAAG,SAAdA,WAAWA,CAAIC,IAAI,EAAEC,IAAI,EAAK;EAClC,kBAAAX,MAAA,CAAkBU,IAAI,UAAAV,MAAA,CAAMW,IAAI,qBAAAX,MAAA,CAAgBW,IAAI;AACtD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMC,KAAK,GAAG,SAARA,KAAKA,CAAIC,KAAK,EAAEf,OAAO,EAAK;EAChC,IAAI,OAAOe,KAAK,KAAK,QAAQ,EAAE;IAC7B,MAAM,IAAIC,SAAS,CAAC,mBAAmB,CAAC;EAC1C;EAEAD,KAAK,GAAGlB,YAAY,CAACkB,KAAK,CAAC,IAAIA,KAAK;EAEpC,IAAME,IAAI,GAAA5B,aAAA,KAAQW,OAAO,CAAE;EAC3B,IAAMkB,GAAG,GAAG,OAAOD,IAAI,CAACE,SAAS,KAAK,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAAC5B,UAAU,EAAEwB,IAAI,CAACE,SAAS,CAAC,GAAG1B,UAAU;EAElG,IAAI6B,GAAG,GAAGP,KAAK,CAACQ,MAAM;EACtB,IAAID,GAAG,GAAGJ,GAAG,EAAE;IACb,MAAM,IAAIM,WAAW,kBAAAtB,MAAA,CAAkBoB,GAAG,wCAAApB,MAAA,CAAqCgB,GAAG,CAAE,CAAC;EACvF;EAEA,IAAMO,GAAG,GAAG;IAAEb,IAAI,EAAE,KAAK;IAAER,KAAK,EAAE,EAAE;IAAEsB,MAAM,EAAET,IAAI,CAACU,OAAO,IAAI;EAAG,CAAC;EAClE,IAAMC,MAAM,GAAG,CAACH,GAAG,CAAC;EAEpB,IAAMI,OAAO,GAAGZ,IAAI,CAACY,OAAO,GAAG,EAAE,GAAG,IAAI;EACxC,IAAMC,KAAK,GAAGtC,KAAK,CAACuC,SAAS,CAAC/B,OAAO,CAAC;;EAEtC;EACA,IAAMgC,cAAc,GAAGzC,SAAS,CAAC0C,SAAS,CAACH,KAAK,CAAC;EACjD,IAAMI,aAAa,GAAG3C,SAAS,CAAC4C,YAAY,CAACH,cAAc,CAAC;EAE5D,IACEI,WAAW,GAYTJ,cAAc,CAZhBI,WAAW;IACXC,YAAY,GAWVL,cAAc,CAXhBK,YAAY;IACZC,aAAa,GAUXN,cAAc,CAVhBM,aAAa;IACbC,QAAQ,GASNP,cAAc,CAThBO,QAAQ;IACRC,UAAU,GAQRR,cAAc,CARhBQ,UAAU;IACVC,MAAM,GAOJT,cAAc,CAPhBS,MAAM;IACNC,YAAY,GAMVV,cAAc,CANhBU,YAAY;IACZC,aAAa,GAKXX,cAAc,CALhBW,aAAa;IACbC,KAAK,GAIHZ,cAAc,CAJhBY,KAAK;IACLC,YAAY,GAGVb,cAAc,CAHhBa,YAAY;IACZC,IAAI,GAEFd,cAAc,CAFhBc,IAAI;IACJC,YAAY,GACVf,cAAc,CADhBe,YAAY;EAGd,IAAMC,QAAQ,GAAG,SAAXA,QAAQA,CAAG/B,IAAI,EAAI;IACvB,WAAAf,MAAA,CAAW2B,OAAO,YAAA3B,MAAA,CAAS6C,YAAY,EAAA7C,MAAA,CAAGe,IAAI,CAACgC,GAAG,GAAGT,UAAU,GAAGJ,WAAW;EAC/E,CAAC;EAED,IAAMc,KAAK,GAAGjC,IAAI,CAACgC,GAAG,GAAG,EAAE,GAAGR,MAAM;EACpC,IAAMU,UAAU,GAAGlC,IAAI,CAACgC,GAAG,GAAGL,KAAK,GAAGC,YAAY;EAClD,IAAIO,IAAI,GAAGnC,IAAI,CAACoC,IAAI,KAAK,IAAI,GAAGL,QAAQ,CAAC/B,IAAI,CAAC,GAAG6B,IAAI;EAErD,IAAI7B,IAAI,CAACY,OAAO,EAAE;IAChBuB,IAAI,OAAAlD,MAAA,CAAOkD,IAAI,MAAG;EACpB;;EAEA;EACA,IAAI,OAAOnC,IAAI,CAACqC,KAAK,KAAK,SAAS,EAAE;IACnCrC,IAAI,CAACsC,SAAS,GAAGtC,IAAI,CAACqC,KAAK;EAC7B;EAEA,IAAME,KAAK,GAAG;IACZzC,KAAK,EAALA,KAAK;IACL0C,KAAK,EAAE,CAAC,CAAC;IACTC,KAAK,EAAE,CAAC;IACRT,GAAG,EAAEhC,IAAI,CAACgC,GAAG,KAAK,IAAI;IACtBU,QAAQ,EAAE,EAAE;IACZjC,MAAM,EAAE,EAAE;IACVkC,MAAM,EAAE,EAAE;IACVC,SAAS,EAAE,KAAK;IAChBC,OAAO,EAAE,KAAK;IACdC,QAAQ,EAAE,CAAC;IACXC,MAAM,EAAE,CAAC;IACTC,MAAM,EAAE,CAAC;IACTC,MAAM,EAAE,CAAC;IACTlB,QAAQ,EAAE,KAAK;IACfpB,MAAM,EAANA;EACF,CAAC;EAEDb,KAAK,GAAGvB,KAAK,CAAC2E,YAAY,CAACpD,KAAK,EAAEyC,KAAK,CAAC;EACxClC,GAAG,GAAGP,KAAK,CAACQ,MAAM;EAElB,IAAM6C,QAAQ,GAAG,EAAE;EACnB,IAAMJ,MAAM,GAAG,EAAE;EACjB,IAAMK,KAAK,GAAG,EAAE;EAChB,IAAIC,IAAI,GAAG7C,GAAG;EACd,IAAIrB,KAAK;;EAET;AACF;AACA;;EAEE,IAAMmE,GAAG,GAAG,SAANA,GAAGA,CAAA;IAAA,OAASf,KAAK,CAACC,KAAK,KAAKnC,GAAG,GAAG,CAAC;EAAA;EACzC,IAAMkD,IAAI,GAAGhB,KAAK,CAACgB,IAAI,GAAG;IAAA,IAACC,CAAC,GAAAC,SAAA,CAAAnD,MAAA,QAAAmD,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC;IAAA,OAAK3D,KAAK,CAACyC,KAAK,CAACC,KAAK,GAAGgB,CAAC,CAAC;EAAA;EAC3D,IAAMG,OAAO,GAAGpB,KAAK,CAACoB,OAAO,GAAG;IAAA,OAAM7D,KAAK,CAAC,EAAEyC,KAAK,CAACC,KAAK,CAAC,IAAI,EAAE;EAAA;EAChE,IAAMoB,SAAS,GAAG,SAAZA,SAASA,CAAA;IAAA,OAAS9D,KAAK,CAAC+D,KAAK,CAACtB,KAAK,CAACC,KAAK,GAAG,CAAC,CAAC;EAAA;EACpD,IAAMsB,OAAO,GAAG,SAAVA,OAAOA,CAAA,EAA4B;IAAA,IAAxB3E,KAAK,GAAAsE,SAAA,CAAAnD,MAAA,QAAAmD,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,EAAE;IAAA,IAAEM,GAAG,GAAAN,SAAA,CAAAnD,MAAA,QAAAmD,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC;IAClClB,KAAK,CAACG,QAAQ,IAAIvD,KAAK;IACvBoD,KAAK,CAACC,KAAK,IAAIuB,GAAG;EACpB,CAAC;EAED,IAAMC,MAAM,GAAG,SAATA,MAAMA,CAAGC,KAAK,EAAI;IACtB1B,KAAK,CAAC9B,MAAM,IAAIwD,KAAK,CAACxD,MAAM,IAAI,IAAI,GAAGwD,KAAK,CAACxD,MAAM,GAAGwD,KAAK,CAAC9E,KAAK;IACjE2E,OAAO,CAACG,KAAK,CAAC9E,KAAK,CAAC;EACtB,CAAC;EAED,IAAM+E,MAAM,GAAG,SAATA,MAAMA,CAAA,EAAS;IACnB,IAAIC,KAAK,GAAG,CAAC;IAEb,OAAOZ,IAAI,CAAC,CAAC,KAAK,GAAG,KAAKA,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,EAAE;MAC7DI,OAAO,CAAC,CAAC;MACTpB,KAAK,CAACE,KAAK,EAAE;MACb0B,KAAK,EAAE;IACT;IAEA,IAAIA,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE;MACnB,OAAO,KAAK;IACd;IAEA5B,KAAK,CAACM,OAAO,GAAG,IAAI;IACpBN,KAAK,CAACE,KAAK,EAAE;IACb,OAAO,IAAI;EACb,CAAC;EAED,IAAM2B,SAAS,GAAG,SAAZA,SAASA,CAAGzE,IAAI,EAAI;IACxB4C,KAAK,CAAC5C,IAAI,CAAC,EAAE;IACbyD,KAAK,CAACiB,IAAI,CAAC1E,IAAI,CAAC;EAClB,CAAC;EAED,IAAM2E,SAAS,GAAG,SAAZA,SAASA,CAAG3E,IAAI,EAAI;IACxB4C,KAAK,CAAC5C,IAAI,CAAC,EAAE;IACbyD,KAAK,CAACmB,GAAG,CAAC,CAAC;EACb,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE,IAAMF,IAAI,GAAG,SAAPA,IAAIA,CAAGG,GAAG,EAAI;IAClB,IAAInB,IAAI,CAAC1D,IAAI,KAAK,UAAU,EAAE;MAC5B,IAAM8E,OAAO,GAAGlC,KAAK,CAACQ,MAAM,GAAG,CAAC,KAAKyB,GAAG,CAAC7E,IAAI,KAAK,OAAO,IAAI6E,GAAG,CAAC7E,IAAI,KAAK,OAAO,CAAC;MAClF,IAAM+E,SAAS,GAAGF,GAAG,CAACG,OAAO,KAAK,IAAI,IAAKxB,QAAQ,CAAC7C,MAAM,KAAKkE,GAAG,CAAC7E,IAAI,KAAK,MAAM,IAAI6E,GAAG,CAAC7E,IAAI,KAAK,OAAO,CAAE;MAE5G,IAAI6E,GAAG,CAAC7E,IAAI,KAAK,OAAO,IAAI6E,GAAG,CAAC7E,IAAI,KAAK,OAAO,IAAI,CAAC8E,OAAO,IAAI,CAACC,SAAS,EAAE;QAC1EnC,KAAK,CAAC9B,MAAM,GAAG8B,KAAK,CAAC9B,MAAM,CAACoD,KAAK,CAAC,CAAC,EAAE,CAACR,IAAI,CAAC5C,MAAM,CAACH,MAAM,CAAC;QACzD+C,IAAI,CAAC1D,IAAI,GAAG,MAAM;QAClB0D,IAAI,CAAClE,KAAK,GAAG,GAAG;QAChBkE,IAAI,CAAC5C,MAAM,GAAG0B,IAAI;QAClBI,KAAK,CAAC9B,MAAM,IAAI4C,IAAI,CAAC5C,MAAM;MAC7B;IACF;IAEA,IAAI0C,QAAQ,CAAC7C,MAAM,IAAIkE,GAAG,CAAC7E,IAAI,KAAK,OAAO,EAAE;MAC3CwD,QAAQ,CAACA,QAAQ,CAAC7C,MAAM,GAAG,CAAC,CAAC,CAACsE,KAAK,IAAIJ,GAAG,CAACrF,KAAK;IAClD;IAEA,IAAIqF,GAAG,CAACrF,KAAK,IAAIqF,GAAG,CAAC/D,MAAM,EAAEuD,MAAM,CAACQ,GAAG,CAAC;IACxC,IAAInB,IAAI,IAAIA,IAAI,CAAC1D,IAAI,KAAK,MAAM,IAAI6E,GAAG,CAAC7E,IAAI,KAAK,MAAM,EAAE;MACvD0D,IAAI,CAAClE,KAAK,IAAIqF,GAAG,CAACrF,KAAK;MACvBkE,IAAI,CAAC5C,MAAM,GAAG,CAAC4C,IAAI,CAAC5C,MAAM,IAAI,EAAE,IAAI+D,GAAG,CAACrF,KAAK;MAC7C;IACF;IAEAqF,GAAG,CAACnB,IAAI,GAAGA,IAAI;IACf1C,MAAM,CAAC0D,IAAI,CAACG,GAAG,CAAC;IAChBnB,IAAI,GAAGmB,GAAG;EACZ,CAAC;EAED,IAAMK,WAAW,GAAG,SAAdA,WAAWA,CAAIlF,IAAI,EAAER,KAAK,EAAK;IACnC,IAAM8E,KAAK,GAAA7F,aAAA,CAAAA,aAAA,KAAQ6C,aAAa,CAAC9B,KAAK,CAAC;MAAE2F,UAAU,EAAE,CAAC;MAAEF,KAAK,EAAE;IAAE,EAAE;IAEnEX,KAAK,CAACZ,IAAI,GAAGA,IAAI;IACjBY,KAAK,CAACjB,MAAM,GAAGT,KAAK,CAACS,MAAM;IAC3BiB,KAAK,CAACxD,MAAM,GAAG8B,KAAK,CAAC9B,MAAM;IAC3B,IAAMA,MAAM,GAAG,CAACT,IAAI,CAACY,OAAO,GAAG,GAAG,GAAG,EAAE,IAAIqD,KAAK,CAACc,IAAI;IAErDX,SAAS,CAAC,QAAQ,CAAC;IACnBC,IAAI,CAAC;MAAE1E,IAAI,EAAJA,IAAI;MAAER,KAAK,EAALA,KAAK;MAAEsB,MAAM,EAAE8B,KAAK,CAAC9B,MAAM,GAAG,EAAE,GAAGa;IAAS,CAAC,CAAC;IAC3D+C,IAAI,CAAC;MAAE1E,IAAI,EAAE,OAAO;MAAEgF,OAAO,EAAE,IAAI;MAAExF,KAAK,EAAEwE,OAAO,CAAC,CAAC;MAAElD,MAAM,EAANA;IAAO,CAAC,CAAC;IAChE0C,QAAQ,CAACkB,IAAI,CAACJ,KAAK,CAAC;EACtB,CAAC;EAED,IAAMe,YAAY,GAAG,SAAfA,YAAYA,CAAGf,KAAK,EAAI;IAC5B,IAAIxD,MAAM,GAAGwD,KAAK,CAACgB,KAAK,IAAIjF,IAAI,CAACY,OAAO,GAAG,GAAG,GAAG,EAAE,CAAC;IACpD,IAAIsE,IAAI;IAER,IAAIjB,KAAK,CAACtE,IAAI,KAAK,QAAQ,EAAE;MAC3B,IAAIwF,WAAW,GAAGhD,IAAI;MAEtB,IAAI8B,KAAK,CAACW,KAAK,IAAIX,KAAK,CAACW,KAAK,CAACtE,MAAM,GAAG,CAAC,IAAI2D,KAAK,CAACW,KAAK,CAACQ,QAAQ,CAAC,GAAG,CAAC,EAAE;QACtED,WAAW,GAAGpD,QAAQ,CAAC/B,IAAI,CAAC;MAC9B;MAEA,IAAImF,WAAW,KAAKhD,IAAI,IAAImB,GAAG,CAAC,CAAC,IAAI,OAAO,CAAC+B,IAAI,CAACzB,SAAS,CAAC,CAAC,CAAC,EAAE;QAC9DnD,MAAM,GAAGwD,KAAK,CAACgB,KAAK,UAAAhG,MAAA,CAAUkG,WAAW,CAAE;MAC7C;MAEA,IAAIlB,KAAK,CAACW,KAAK,CAACQ,QAAQ,CAAC,GAAG,CAAC,KAAKF,IAAI,GAAGtB,SAAS,CAAC,CAAC,CAAC,IAAI,cAAc,CAACyB,IAAI,CAACH,IAAI,CAAC,EAAE;QAClF;QACA;QACA;QACA;QACA;QACA,IAAMI,UAAU,GAAGzF,KAAK,CAACqF,IAAI,EAAA9G,aAAA,CAAAA,aAAA,KAAOW,OAAO;UAAEwG,SAAS,EAAE;QAAK,EAAE,CAAC,CAAC9E,MAAM;QAEvEA,MAAM,GAAGwD,KAAK,CAACgB,KAAK,OAAAhG,MAAA,CAAOqG,UAAU,OAAArG,MAAA,CAAIkG,WAAW,MAAG;MACzD;MAEA,IAAIlB,KAAK,CAACZ,IAAI,CAAC1D,IAAI,KAAK,KAAK,EAAE;QAC7B4C,KAAK,CAACiD,cAAc,GAAG,IAAI;MAC7B;IACF;IAEAnB,IAAI,CAAC;MAAE1E,IAAI,EAAE,OAAO;MAAEgF,OAAO,EAAE,IAAI;MAAExF,KAAK,EAALA,KAAK;MAAEsB,MAAM,EAANA;IAAO,CAAC,CAAC;IACrD6D,SAAS,CAAC,QAAQ,CAAC;EACrB,CAAC;;EAED;AACF;AACA;;EAEE,IAAItE,IAAI,CAACuF,SAAS,KAAK,KAAK,IAAI,CAAC,qBAAqB,CAACF,IAAI,CAACvF,KAAK,CAAC,EAAE;IAClE,IAAI2F,WAAW,GAAG,KAAK;IAEvB,IAAIhF,MAAM,GAAGX,KAAK,CAAC4F,OAAO,CAAC/G,2BAA2B,EAAE,UAACgH,CAAC,EAAEC,GAAG,EAAEC,KAAK,EAAEC,KAAK,EAAEZ,IAAI,EAAE1C,KAAK,EAAK;MAC7F,IAAIsD,KAAK,KAAK,IAAI,EAAE;QAClBL,WAAW,GAAG,IAAI;QAClB,OAAOE,CAAC;MACV;MAEA,IAAIG,KAAK,KAAK,GAAG,EAAE;QACjB,IAAIF,GAAG,EAAE;UACP,OAAOA,GAAG,GAAGE,KAAK,IAAIZ,IAAI,GAAGvD,KAAK,CAACoE,MAAM,CAACb,IAAI,CAAC5E,MAAM,CAAC,GAAG,EAAE,CAAC;QAC9D;QACA,IAAIkC,KAAK,KAAK,CAAC,EAAE;UACf,OAAON,UAAU,IAAIgD,IAAI,GAAGvD,KAAK,CAACoE,MAAM,CAACb,IAAI,CAAC5E,MAAM,CAAC,GAAG,EAAE,CAAC;QAC7D;QACA,OAAOqB,KAAK,CAACoE,MAAM,CAACF,KAAK,CAACvF,MAAM,CAAC;MACnC;MAEA,IAAIwF,KAAK,KAAK,GAAG,EAAE;QACjB,OAAO3E,WAAW,CAAC4E,MAAM,CAACF,KAAK,CAACvF,MAAM,CAAC;MACzC;MAEA,IAAIwF,KAAK,KAAK,GAAG,EAAE;QACjB,IAAIF,GAAG,EAAE;UACP,OAAOA,GAAG,GAAGE,KAAK,IAAIZ,IAAI,GAAG/C,IAAI,GAAG,EAAE,CAAC;QACzC;QACA,OAAOA,IAAI;MACb;MACA,OAAOyD,GAAG,GAAGD,CAAC,QAAA1G,MAAA,CAAQ0G,CAAC,CAAE;IAC3B,CAAC,CAAC;IAEF,IAAIF,WAAW,KAAK,IAAI,EAAE;MACxB,IAAIzF,IAAI,CAACgG,QAAQ,KAAK,IAAI,EAAE;QAC1BvF,MAAM,GAAGA,MAAM,CAACiF,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;MACpC,CAAC,MAAM;QACLjF,MAAM,GAAGA,MAAM,CAACiF,OAAO,CAAC,MAAM,EAAE,UAAAC,CAAC,EAAI;UACnC,OAAOA,CAAC,CAACrF,MAAM,GAAG,CAAC,KAAK,CAAC,GAAG,MAAM,GAAIqF,CAAC,GAAG,IAAI,GAAG,EAAG;QACtD,CAAC,CAAC;MACJ;IACF;IAEA,IAAIlF,MAAM,KAAKX,KAAK,IAAIE,IAAI,CAACiG,QAAQ,KAAK,IAAI,EAAE;MAC9C1D,KAAK,CAAC9B,MAAM,GAAGX,KAAK;MACpB,OAAOyC,KAAK;IACd;IAEAA,KAAK,CAAC9B,MAAM,GAAGlC,KAAK,CAAC2H,UAAU,CAACzF,MAAM,EAAE8B,KAAK,EAAExD,OAAO,CAAC;IACvD,OAAOwD,KAAK;EACd;;EAEA;AACF;AACA;;EAEE,OAAO,CAACe,GAAG,CAAC,CAAC,EAAE;IACbnE,KAAK,GAAGwE,OAAO,CAAC,CAAC;IAEjB,IAAIxE,KAAK,KAAK,IAAQ,EAAE;MACtB;IACF;;IAEA;AACJ;AACA;;IAEI,IAAIA,KAAK,KAAK,IAAI,EAAE;MAClB,IAAMgH,IAAI,GAAG5C,IAAI,CAAC,CAAC;MAEnB,IAAI4C,IAAI,KAAK,GAAG,IAAInG,IAAI,CAACoC,IAAI,KAAK,IAAI,EAAE;QACtC;MACF;MAEA,IAAI+D,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,EAAE;QAChC;MACF;MAEA,IAAI,CAACA,IAAI,EAAE;QACThH,KAAK,IAAI,IAAI;QACbkF,IAAI,CAAC;UAAE1E,IAAI,EAAE,MAAM;UAAER,KAAK,EAALA;QAAM,CAAC,CAAC;QAC7B;MACF;;MAEA;MACA,IAAMiH,KAAK,GAAG,MAAM,CAACC,IAAI,CAACzC,SAAS,CAAC,CAAC,CAAC;MACtC,IAAI0C,OAAO,GAAG,CAAC;MAEf,IAAIF,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,CAAC9F,MAAM,GAAG,CAAC,EAAE;QAChCgG,OAAO,GAAGF,KAAK,CAAC,CAAC,CAAC,CAAC9F,MAAM;QACzBiC,KAAK,CAACC,KAAK,IAAI8D,OAAO;QACtB,IAAIA,OAAO,GAAG,CAAC,KAAK,CAAC,EAAE;UACrBnH,KAAK,IAAI,IAAI;QACf;MACF;MAEA,IAAIa,IAAI,CAACgG,QAAQ,KAAK,IAAI,EAAE;QAC1B7G,KAAK,GAAGwE,OAAO,CAAC,CAAC;MACnB,CAAC,MAAM;QACLxE,KAAK,IAAIwE,OAAO,CAAC,CAAC;MACpB;MAEA,IAAIpB,KAAK,CAACO,QAAQ,KAAK,CAAC,EAAE;QACxBuB,IAAI,CAAC;UAAE1E,IAAI,EAAE,MAAM;UAAER,KAAK,EAALA;QAAM,CAAC,CAAC;QAC7B;MACF;IACF;;IAEA;AACJ;AACA;AACA;;IAEI,IAAIoD,KAAK,CAACO,QAAQ,GAAG,CAAC,KAAK3D,KAAK,KAAK,GAAG,IAAIkE,IAAI,CAAClE,KAAK,KAAK,GAAG,IAAIkE,IAAI,CAAClE,KAAK,KAAK,IAAI,CAAC,EAAE;MACtF,IAAIa,IAAI,CAACuG,KAAK,KAAK,KAAK,IAAIpH,KAAK,KAAK,GAAG,EAAE;QACzC,IAAMyF,KAAK,GAAGvB,IAAI,CAAClE,KAAK,CAAC0E,KAAK,CAAC,CAAC,CAAC;QACjC,IAAIe,KAAK,CAACQ,QAAQ,CAAC,GAAG,CAAC,EAAE;UACvB/B,IAAI,CAACkD,KAAK,GAAG,IAAI;UAEjB,IAAI3B,KAAK,CAACQ,QAAQ,CAAC,GAAG,CAAC,EAAE;YACvB,IAAMoB,GAAG,GAAGnD,IAAI,CAAClE,KAAK,CAACsH,WAAW,CAAC,GAAG,CAAC;YACvC,IAAMC,GAAG,GAAGrD,IAAI,CAAClE,KAAK,CAAC0E,KAAK,CAAC,CAAC,EAAE2C,GAAG,CAAC;YACpC,IAAMtB,KAAI,GAAG7B,IAAI,CAAClE,KAAK,CAAC0E,KAAK,CAAC2C,GAAG,GAAG,CAAC,CAAC;YACtC,IAAMD,KAAK,GAAG9H,kBAAkB,CAACyG,KAAI,CAAC;YACtC,IAAIqB,KAAK,EAAE;cACTlD,IAAI,CAAClE,KAAK,GAAGuH,GAAG,GAAGH,KAAK;cACxBhE,KAAK,CAACK,SAAS,GAAG,IAAI;cACtBe,OAAO,CAAC,CAAC;cAET,IAAI,CAACnD,GAAG,CAACC,MAAM,IAAIE,MAAM,CAACgG,OAAO,CAACtD,IAAI,CAAC,KAAK,CAAC,EAAE;gBAC7C7C,GAAG,CAACC,MAAM,GAAGa,QAAQ;cACvB;cACA;YACF;UACF;QACF;MACF;MAEA,IAAKnC,KAAK,KAAK,GAAG,IAAIoE,IAAI,CAAC,CAAC,KAAK,GAAG,IAAMpE,KAAK,KAAK,GAAG,IAAIoE,IAAI,CAAC,CAAC,KAAK,GAAI,EAAE;QAC1EpE,KAAK,QAAAF,MAAA,CAAQE,KAAK,CAAE;MACtB;MAEA,IAAIA,KAAK,KAAK,GAAG,KAAKkE,IAAI,CAAClE,KAAK,KAAK,GAAG,IAAIkE,IAAI,CAAClE,KAAK,KAAK,IAAI,CAAC,EAAE;QAChEA,KAAK,QAAAF,MAAA,CAAQE,KAAK,CAAE;MACtB;MAEA,IAAIa,IAAI,CAACuG,KAAK,KAAK,IAAI,IAAIpH,KAAK,KAAK,GAAG,IAAIkE,IAAI,CAAClE,KAAK,KAAK,GAAG,EAAE;QAC9DA,KAAK,GAAG,GAAG;MACb;MAEAkE,IAAI,CAAClE,KAAK,IAAIA,KAAK;MACnB6E,MAAM,CAAC;QAAE7E,KAAK,EAALA;MAAM,CAAC,CAAC;MACjB;IACF;;IAEA;AACJ;AACA;AACA;;IAEI,IAAIoD,KAAK,CAACU,MAAM,KAAK,CAAC,IAAI9D,KAAK,KAAK,GAAG,EAAE;MACvCA,KAAK,GAAGZ,KAAK,CAACkB,WAAW,CAACN,KAAK,CAAC;MAChCkE,IAAI,CAAClE,KAAK,IAAIA,KAAK;MACnB6E,MAAM,CAAC;QAAE7E,KAAK,EAALA;MAAM,CAAC,CAAC;MACjB;IACF;;IAEA;AACJ;AACA;;IAEI,IAAIA,KAAK,KAAK,GAAG,EAAE;MACjBoD,KAAK,CAACU,MAAM,GAAGV,KAAK,CAACU,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;MACzC,IAAIjD,IAAI,CAAC4G,UAAU,KAAK,IAAI,EAAE;QAC5BvC,IAAI,CAAC;UAAE1E,IAAI,EAAE,MAAM;UAAER,KAAK,EAALA;QAAM,CAAC,CAAC;MAC/B;MACA;IACF;;IAEA;AACJ;AACA;;IAEI,IAAIA,KAAK,KAAK,GAAG,EAAE;MACjBiF,SAAS,CAAC,QAAQ,CAAC;MACnBC,IAAI,CAAC;QAAE1E,IAAI,EAAE,OAAO;QAAER,KAAK,EAALA;MAAM,CAAC,CAAC;MAC9B;IACF;IAEA,IAAIA,KAAK,KAAK,GAAG,EAAE;MACjB,IAAIoD,KAAK,CAACS,MAAM,KAAK,CAAC,IAAIhD,IAAI,CAAC6G,cAAc,KAAK,IAAI,EAAE;QACtD,MAAM,IAAItG,WAAW,CAACb,WAAW,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;MACpD;MAEA,IAAMiF,OAAO,GAAGxB,QAAQ,CAACA,QAAQ,CAAC7C,MAAM,GAAG,CAAC,CAAC;MAC7C,IAAIqE,OAAO,IAAIpC,KAAK,CAACS,MAAM,KAAK2B,OAAO,CAAC3B,MAAM,GAAG,CAAC,EAAE;QAClDgC,YAAY,CAAC7B,QAAQ,CAACoB,GAAG,CAAC,CAAC,CAAC;QAC5B;MACF;MAEAF,IAAI,CAAC;QAAE1E,IAAI,EAAE,OAAO;QAAER,KAAK,EAALA,KAAK;QAAEsB,MAAM,EAAE8B,KAAK,CAACS,MAAM,GAAG,GAAG,GAAG;MAAM,CAAC,CAAC;MAClEsB,SAAS,CAAC,QAAQ,CAAC;MACnB;IACF;;IAEA;AACJ;AACA;;IAEI,IAAInF,KAAK,KAAK,GAAG,EAAE;MACjB,IAAIa,IAAI,CAAC8G,SAAS,KAAK,IAAI,IAAI,CAAClD,SAAS,CAAC,CAAC,CAACwB,QAAQ,CAAC,GAAG,CAAC,EAAE;QACzD,IAAIpF,IAAI,CAAC8G,SAAS,KAAK,IAAI,IAAI9G,IAAI,CAAC6G,cAAc,KAAK,IAAI,EAAE;UAC3D,MAAM,IAAItG,WAAW,CAACb,WAAW,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;QACpD;QAEAP,KAAK,QAAAF,MAAA,CAAQE,KAAK,CAAE;MACtB,CAAC,MAAM;QACLiF,SAAS,CAAC,UAAU,CAAC;MACvB;MAEAC,IAAI,CAAC;QAAE1E,IAAI,EAAE,SAAS;QAAER,KAAK,EAALA;MAAM,CAAC,CAAC;MAChC;IACF;IAEA,IAAIA,KAAK,KAAK,GAAG,EAAE;MACjB,IAAIa,IAAI,CAAC8G,SAAS,KAAK,IAAI,IAAKzD,IAAI,IAAIA,IAAI,CAAC1D,IAAI,KAAK,SAAS,IAAI0D,IAAI,CAAClE,KAAK,CAACmB,MAAM,KAAK,CAAE,EAAE;QAC3F+D,IAAI,CAAC;UAAE1E,IAAI,EAAE,MAAM;UAAER,KAAK,EAALA,KAAK;UAAEsB,MAAM,OAAAxB,MAAA,CAAOE,KAAK;QAAG,CAAC,CAAC;QACnD;MACF;MAEA,IAAIoD,KAAK,CAACO,QAAQ,KAAK,CAAC,EAAE;QACxB,IAAI9C,IAAI,CAAC6G,cAAc,KAAK,IAAI,EAAE;UAChC,MAAM,IAAItG,WAAW,CAACb,WAAW,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;QACpD;QAEA2E,IAAI,CAAC;UAAE1E,IAAI,EAAE,MAAM;UAAER,KAAK,EAALA,KAAK;UAAEsB,MAAM,OAAAxB,MAAA,CAAOE,KAAK;QAAG,CAAC,CAAC;QACnD;MACF;MAEAmF,SAAS,CAAC,UAAU,CAAC;MAErB,IAAMyC,SAAS,GAAG1D,IAAI,CAAClE,KAAK,CAAC0E,KAAK,CAAC,CAAC,CAAC;MACrC,IAAIR,IAAI,CAACkD,KAAK,KAAK,IAAI,IAAIQ,SAAS,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,CAACA,SAAS,CAAC3B,QAAQ,CAAC,GAAG,CAAC,EAAE;QAC3EjG,KAAK,OAAAF,MAAA,CAAOE,KAAK,CAAE;MACrB;MAEAkE,IAAI,CAAClE,KAAK,IAAIA,KAAK;MACnB6E,MAAM,CAAC;QAAE7E,KAAK,EAALA;MAAM,CAAC,CAAC;;MAEjB;MACA;MACA,IAAIa,IAAI,CAACgH,eAAe,KAAK,KAAK,IAAIzI,KAAK,CAAC0I,aAAa,CAACF,SAAS,CAAC,EAAE;QACpE;MACF;MAEA,IAAMG,OAAO,GAAG3I,KAAK,CAACkB,WAAW,CAAC4D,IAAI,CAAClE,KAAK,CAAC;MAC7CoD,KAAK,CAAC9B,MAAM,GAAG8B,KAAK,CAAC9B,MAAM,CAACoD,KAAK,CAAC,CAAC,EAAE,CAACR,IAAI,CAAClE,KAAK,CAACmB,MAAM,CAAC;;MAExD;MACA;MACA,IAAIN,IAAI,CAACgH,eAAe,KAAK,IAAI,EAAE;QACjCzE,KAAK,CAAC9B,MAAM,IAAIyG,OAAO;QACvB7D,IAAI,CAAClE,KAAK,GAAG+H,OAAO;QACpB;MACF;;MAEA;MACA7D,IAAI,CAAClE,KAAK,OAAAF,MAAA,CAAO2B,OAAO,EAAA3B,MAAA,CAAGiI,OAAO,OAAAjI,MAAA,CAAIoE,IAAI,CAAClE,KAAK,MAAG;MACnDoD,KAAK,CAAC9B,MAAM,IAAI4C,IAAI,CAAClE,KAAK;MAC1B;IACF;;IAEA;AACJ;AACA;;IAEI,IAAIA,KAAK,KAAK,GAAG,IAAIa,IAAI,CAACmH,OAAO,KAAK,IAAI,EAAE;MAC1C/C,SAAS,CAAC,QAAQ,CAAC;MAEnB,IAAMW,IAAI,GAAG;QACXpF,IAAI,EAAE,OAAO;QACbR,KAAK,EAALA,KAAK;QACLsB,MAAM,EAAE,GAAG;QACX2G,WAAW,EAAE7E,KAAK,CAAC9B,MAAM,CAACH,MAAM;QAChC+G,WAAW,EAAE9E,KAAK,CAAC5B,MAAM,CAACL;MAC5B,CAAC;MAEDyC,MAAM,CAACsB,IAAI,CAACU,IAAI,CAAC;MACjBV,IAAI,CAACU,IAAI,CAAC;MACV;IACF;IAEA,IAAI5F,KAAK,KAAK,GAAG,EAAE;MACjB,IAAMmI,KAAK,GAAGvE,MAAM,CAACA,MAAM,CAACzC,MAAM,GAAG,CAAC,CAAC;MAEvC,IAAIN,IAAI,CAACmH,OAAO,KAAK,IAAI,IAAI,CAACG,KAAK,EAAE;QACnCjD,IAAI,CAAC;UAAE1E,IAAI,EAAE,MAAM;UAAER,KAAK,EAALA,KAAK;UAAEsB,MAAM,EAAEtB;QAAM,CAAC,CAAC;QAC5C;MACF;MAEA,IAAIsB,OAAM,GAAG,GAAG;MAEhB,IAAI6G,KAAK,CAACC,IAAI,KAAK,IAAI,EAAE;QACvB,IAAMC,GAAG,GAAG7G,MAAM,CAACkD,KAAK,CAAC,CAAC;QAC1B,IAAM4D,KAAK,GAAG,EAAE;QAEhB,KAAK,IAAIC,CAAC,GAAGF,GAAG,CAAClH,MAAM,GAAG,CAAC,EAAEoH,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UACxC/G,MAAM,CAAC4D,GAAG,CAAC,CAAC;UACZ,IAAIiD,GAAG,CAACE,CAAC,CAAC,CAAC/H,IAAI,KAAK,OAAO,EAAE;YAC3B;UACF;UACA,IAAI6H,GAAG,CAACE,CAAC,CAAC,CAAC/H,IAAI,KAAK,MAAM,EAAE;YAC1B8H,KAAK,CAACE,OAAO,CAACH,GAAG,CAACE,CAAC,CAAC,CAACvI,KAAK,CAAC;UAC7B;QACF;QAEAsB,OAAM,GAAG5B,WAAW,CAAC4I,KAAK,EAAEzH,IAAI,CAAC;QACjCuC,KAAK,CAACK,SAAS,GAAG,IAAI;MACxB;MAEA,IAAI0E,KAAK,CAACM,KAAK,KAAK,IAAI,IAAIN,KAAK,CAACC,IAAI,KAAK,IAAI,EAAE;QAC/C,IAAMM,GAAG,GAAGtF,KAAK,CAAC9B,MAAM,CAACoD,KAAK,CAAC,CAAC,EAAEyD,KAAK,CAACF,WAAW,CAAC;QACpD,IAAMU,IAAI,GAAGvF,KAAK,CAAC5B,MAAM,CAACkD,KAAK,CAACyD,KAAK,CAACD,WAAW,CAAC;QAClDC,KAAK,CAACnI,KAAK,GAAGmI,KAAK,CAAC7G,MAAM,GAAG,KAAK;QAClCtB,KAAK,GAAGsB,OAAM,GAAG,KAAK;QACtB8B,KAAK,CAAC9B,MAAM,GAAGoH,GAAG;QAAC,IAAAE,SAAA,GAAA9J,0BAAA,CACH6J,IAAI;UAAAE,KAAA;QAAA;UAApB,KAAAD,SAAA,CAAAE,CAAA,MAAAD,KAAA,GAAAD,SAAA,CAAAvE,CAAA,IAAA0E,IAAA,GAAsB;YAAA,IAAXC,CAAC,GAAAH,KAAA,CAAA7I,KAAA;YACVoD,KAAK,CAAC9B,MAAM,IAAK0H,CAAC,CAAC1H,MAAM,IAAI0H,CAAC,CAAChJ,KAAM;UACvC;QAAC,SAAAiJ,GAAA;UAAAL,SAAA,CAAAM,CAAA,CAAAD,GAAA;QAAA;UAAAL,SAAA,CAAAO,CAAA;QAAA;MACH;MAEAjE,IAAI,CAAC;QAAE1E,IAAI,EAAE,OAAO;QAAER,KAAK,EAALA,KAAK;QAAEsB,MAAM,EAANA;MAAO,CAAC,CAAC;MACtC6D,SAAS,CAAC,QAAQ,CAAC;MACnBvB,MAAM,CAACwB,GAAG,CAAC,CAAC;MACZ;IACF;;IAEA;AACJ;AACA;;IAEI,IAAIpF,KAAK,KAAK,GAAG,EAAE;MACjB,IAAIgE,QAAQ,CAAC7C,MAAM,GAAG,CAAC,EAAE;QACvB6C,QAAQ,CAACA,QAAQ,CAAC7C,MAAM,GAAG,CAAC,CAAC,CAACwE,UAAU,EAAE;MAC5C;MACAT,IAAI,CAAC;QAAE1E,IAAI,EAAE,MAAM;QAAER,KAAK,EAALA;MAAM,CAAC,CAAC;MAC7B;IACF;;IAEA;AACJ;AACA;;IAEI,IAAIA,KAAK,KAAK,GAAG,EAAE;MACjB,IAAIsB,QAAM,GAAGtB,KAAK;MAElB,IAAMmI,MAAK,GAAGvE,MAAM,CAACA,MAAM,CAACzC,MAAM,GAAG,CAAC,CAAC;MACvC,IAAIgH,MAAK,IAAIlE,KAAK,CAACA,KAAK,CAAC9C,MAAM,GAAG,CAAC,CAAC,KAAK,QAAQ,EAAE;QACjDgH,MAAK,CAACM,KAAK,GAAG,IAAI;QAClBnH,QAAM,GAAG,GAAG;MACd;MAEA4D,IAAI,CAAC;QAAE1E,IAAI,EAAE,OAAO;QAAER,KAAK,EAALA,KAAK;QAAEsB,MAAM,EAANA;MAAO,CAAC,CAAC;MACtC;IACF;;IAEA;AACJ;AACA;;IAEI,IAAItB,KAAK,KAAK,GAAG,EAAE;MACjB;MACA;MACA;MACA;MACA,IAAIkE,IAAI,CAAC1D,IAAI,KAAK,KAAK,IAAI4C,KAAK,CAACC,KAAK,KAAKD,KAAK,CAACE,KAAK,GAAG,CAAC,EAAE;QAC1DF,KAAK,CAACE,KAAK,GAAGF,KAAK,CAACC,KAAK,GAAG,CAAC;QAC7BD,KAAK,CAACG,QAAQ,GAAG,EAAE;QACnBH,KAAK,CAAC9B,MAAM,GAAG,EAAE;QACjBE,MAAM,CAAC4D,GAAG,CAAC,CAAC;QACZlB,IAAI,GAAG7C,GAAG,CAAC,CAAC;QACZ;MACF;MAEA6D,IAAI,CAAC;QAAE1E,IAAI,EAAE,OAAO;QAAER,KAAK,EAALA,KAAK;QAAEsB,MAAM,EAAEY;MAAc,CAAC,CAAC;MACrD;IACF;;IAEA;AACJ;AACA;;IAEI,IAAIlC,KAAK,KAAK,GAAG,EAAE;MACjB,IAAIoD,KAAK,CAACQ,MAAM,GAAG,CAAC,IAAIM,IAAI,CAAC1D,IAAI,KAAK,KAAK,EAAE;QAC3C,IAAI0D,IAAI,CAAClE,KAAK,KAAK,GAAG,EAAEkE,IAAI,CAAC5C,MAAM,GAAGU,WAAW;QACjD,IAAMmG,OAAK,GAAGvE,MAAM,CAACA,MAAM,CAACzC,MAAM,GAAG,CAAC,CAAC;QACvC+C,IAAI,CAAC1D,IAAI,GAAG,MAAM;QAClB0D,IAAI,CAAC5C,MAAM,IAAItB,KAAK;QACpBkE,IAAI,CAAClE,KAAK,IAAIA,KAAK;QACnBmI,OAAK,CAACC,IAAI,GAAG,IAAI;QACjB;MACF;MAEA,IAAKhF,KAAK,CAACQ,MAAM,GAAGR,KAAK,CAACS,MAAM,KAAM,CAAC,IAAIK,IAAI,CAAC1D,IAAI,KAAK,KAAK,IAAI0D,IAAI,CAAC1D,IAAI,KAAK,OAAO,EAAE;QACvF0E,IAAI,CAAC;UAAE1E,IAAI,EAAE,MAAM;UAAER,KAAK,EAALA,KAAK;UAAEsB,MAAM,EAAEU;QAAY,CAAC,CAAC;QAClD;MACF;MAEAkD,IAAI,CAAC;QAAE1E,IAAI,EAAE,KAAK;QAAER,KAAK,EAALA,KAAK;QAAEsB,MAAM,EAAEU;MAAY,CAAC,CAAC;MACjD;IACF;;IAEA;AACJ;AACA;;IAEI,IAAIhC,KAAK,KAAK,GAAG,EAAE;MACjB,IAAMoJ,OAAO,GAAGlF,IAAI,IAAIA,IAAI,CAAClE,KAAK,KAAK,GAAG;MAC1C,IAAI,CAACoJ,OAAO,IAAIvI,IAAI,CAACsC,SAAS,KAAK,IAAI,IAAIiB,IAAI,CAAC,CAAC,KAAK,GAAG,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC5EsB,WAAW,CAAC,OAAO,EAAE1F,KAAK,CAAC;QAC3B;MACF;MAEA,IAAIkE,IAAI,IAAIA,IAAI,CAAC1D,IAAI,KAAK,OAAO,EAAE;QACjC,IAAMwG,KAAI,GAAG5C,IAAI,CAAC,CAAC;QACnB,IAAI9C,QAAM,GAAGtB,KAAK;QAElB,IAAIgH,KAAI,KAAK,GAAG,IAAI,CAAC5H,KAAK,CAACiK,mBAAmB,CAAC,CAAC,EAAE;UAChD,MAAM,IAAIC,KAAK,CAAC,yDAAyD,CAAC;QAC5E;QAEA,IAAKpF,IAAI,CAAClE,KAAK,KAAK,GAAG,IAAI,CAAC,QAAQ,CAACkG,IAAI,CAACc,KAAI,CAAC,IAAMA,KAAI,KAAK,GAAG,IAAI,CAAC,cAAc,CAACd,IAAI,CAACzB,SAAS,CAAC,CAAC,CAAE,EAAE;UACvGnD,QAAM,QAAAxB,MAAA,CAAQE,KAAK,CAAE;QACvB;QAEAkF,IAAI,CAAC;UAAE1E,IAAI,EAAE,MAAM;UAAER,KAAK,EAALA,KAAK;UAAEsB,MAAM,EAANA;QAAO,CAAC,CAAC;QACrC;MACF;MAEA,IAAIT,IAAI,CAACgC,GAAG,KAAK,IAAI,KAAKqB,IAAI,CAAC1D,IAAI,KAAK,OAAO,IAAI0D,IAAI,CAAC1D,IAAI,KAAK,KAAK,CAAC,EAAE;QACvE0E,IAAI,CAAC;UAAE1E,IAAI,EAAE,OAAO;UAAER,KAAK,EAALA,KAAK;UAAEsB,MAAM,EAAEmB;QAAa,CAAC,CAAC;QACpD;MACF;MAEAyC,IAAI,CAAC;QAAE1E,IAAI,EAAE,OAAO;QAAER,KAAK,EAALA,KAAK;QAAEsB,MAAM,EAAEkB;MAAM,CAAC,CAAC;MAC7C;IACF;;IAEA;AACJ;AACA;;IAEI,IAAIxC,KAAK,KAAK,GAAG,EAAE;MACjB,IAAIa,IAAI,CAACsC,SAAS,KAAK,IAAI,IAAIiB,IAAI,CAAC,CAAC,KAAK,GAAG,EAAE;QAC7C,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC8B,IAAI,CAAC9B,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;UAC9CsB,WAAW,CAAC,QAAQ,EAAE1F,KAAK,CAAC;UAC5B;QACF;MACF;MAEA,IAAIa,IAAI,CAAC0I,QAAQ,KAAK,IAAI,IAAInG,KAAK,CAACC,KAAK,KAAK,CAAC,EAAE;QAC/C0B,MAAM,CAAC,CAAC;QACR;MACF;IACF;;IAEA;AACJ;AACA;;IAEI,IAAI/E,KAAK,KAAK,GAAG,EAAE;MACjB,IAAIa,IAAI,CAACsC,SAAS,KAAK,IAAI,IAAIiB,IAAI,CAAC,CAAC,KAAK,GAAG,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAChEsB,WAAW,CAAC,MAAM,EAAE1F,KAAK,CAAC;QAC1B;MACF;MAEA,IAAKkE,IAAI,IAAIA,IAAI,CAAClE,KAAK,KAAK,GAAG,IAAKa,IAAI,CAAC2I,KAAK,KAAK,KAAK,EAAE;QACxDtE,IAAI,CAAC;UAAE1E,IAAI,EAAE,MAAM;UAAER,KAAK,EAALA,KAAK;UAAEsB,MAAM,EAAEW;QAAa,CAAC,CAAC;QACnD;MACF;MAEA,IAAKiC,IAAI,KAAKA,IAAI,CAAC1D,IAAI,KAAK,SAAS,IAAI0D,IAAI,CAAC1D,IAAI,KAAK,OAAO,IAAI0D,IAAI,CAAC1D,IAAI,KAAK,OAAO,CAAC,IAAK4C,KAAK,CAACS,MAAM,GAAG,CAAC,EAAE;QAC7GqB,IAAI,CAAC;UAAE1E,IAAI,EAAE,MAAM;UAAER,KAAK,EAALA;QAAM,CAAC,CAAC;QAC7B;MACF;MAEAkF,IAAI,CAAC;QAAE1E,IAAI,EAAE,MAAM;QAAER,KAAK,EAAEiC;MAAa,CAAC,CAAC;MAC3C;IACF;;IAEA;AACJ;AACA;;IAEI,IAAIjC,KAAK,KAAK,GAAG,EAAE;MACjB,IAAIa,IAAI,CAACsC,SAAS,KAAK,IAAI,IAAIiB,IAAI,CAAC,CAAC,KAAK,GAAG,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAChEc,IAAI,CAAC;UAAE1E,IAAI,EAAE,IAAI;UAAEgF,OAAO,EAAE,IAAI;UAAExF,KAAK,EAALA,KAAK;UAAEsB,MAAM,EAAE;QAAG,CAAC,CAAC;QACtD;MACF;MAEA4D,IAAI,CAAC;QAAE1E,IAAI,EAAE,MAAM;QAAER,KAAK,EAALA;MAAM,CAAC,CAAC;MAC7B;IACF;;IAEA;AACJ;AACA;;IAEI,IAAIA,KAAK,KAAK,GAAG,EAAE;MACjB,IAAIA,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,GAAG,EAAE;QAClCA,KAAK,QAAAF,MAAA,CAAQE,KAAK,CAAE;MACtB;MAEA,IAAMiH,MAAK,GAAG1H,uBAAuB,CAAC2H,IAAI,CAACzC,SAAS,CAAC,CAAC,CAAC;MACvD,IAAIwC,MAAK,EAAE;QACTjH,KAAK,IAAIiH,MAAK,CAAC,CAAC,CAAC;QACjB7D,KAAK,CAACC,KAAK,IAAI4D,MAAK,CAAC,CAAC,CAAC,CAAC9F,MAAM;MAChC;MAEA+D,IAAI,CAAC;QAAE1E,IAAI,EAAE,MAAM;QAAER,KAAK,EAALA;MAAM,CAAC,CAAC;MAC7B;IACF;;IAEA;AACJ;AACA;;IAEI,IAAIkE,IAAI,KAAKA,IAAI,CAAC1D,IAAI,KAAK,UAAU,IAAI0D,IAAI,CAAClB,IAAI,KAAK,IAAI,CAAC,EAAE;MAC5DkB,IAAI,CAAC1D,IAAI,GAAG,MAAM;MAClB0D,IAAI,CAAClB,IAAI,GAAG,IAAI;MAChBkB,IAAI,CAAClE,KAAK,IAAIA,KAAK;MACnBkE,IAAI,CAAC5C,MAAM,GAAG0B,IAAI;MAClBI,KAAK,CAACK,SAAS,GAAG,IAAI;MACtBL,KAAK,CAACR,QAAQ,GAAG,IAAI;MACrB+B,OAAO,CAAC3E,KAAK,CAAC;MACd;IACF;IAEA,IAAI+F,IAAI,GAAGtB,SAAS,CAAC,CAAC;IACtB,IAAI5D,IAAI,CAACsC,SAAS,KAAK,IAAI,IAAI,SAAS,CAAC+C,IAAI,CAACH,IAAI,CAAC,EAAE;MACnDL,WAAW,CAAC,MAAM,EAAE1F,KAAK,CAAC;MAC1B;IACF;IAEA,IAAIkE,IAAI,CAAC1D,IAAI,KAAK,MAAM,EAAE;MACxB,IAAIK,IAAI,CAAC4I,UAAU,KAAK,IAAI,EAAE;QAC5B9E,OAAO,CAAC3E,KAAK,CAAC;QACd;MACF;MAEA,IAAM0J,KAAK,GAAGxF,IAAI,CAACA,IAAI;MACvB,IAAMyF,MAAM,GAAGD,KAAK,CAACxF,IAAI;MACzB,IAAM0F,OAAO,GAAGF,KAAK,CAAClJ,IAAI,KAAK,OAAO,IAAIkJ,KAAK,CAAClJ,IAAI,KAAK,KAAK;MAC9D,IAAMqJ,SAAS,GAAGF,MAAM,KAAKA,MAAM,CAACnJ,IAAI,KAAK,MAAM,IAAImJ,MAAM,CAACnJ,IAAI,KAAK,UAAU,CAAC;MAElF,IAAIK,IAAI,CAACoC,IAAI,KAAK,IAAI,KAAK,CAAC2G,OAAO,IAAK7D,IAAI,CAAC,CAAC,CAAC,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,GAAI,CAAC,EAAE;QACpEb,IAAI,CAAC;UAAE1E,IAAI,EAAE,MAAM;UAAER,KAAK,EAALA,KAAK;UAAEsB,MAAM,EAAE;QAAG,CAAC,CAAC;QACzC;MACF;MAEA,IAAMgE,OAAO,GAAGlC,KAAK,CAACQ,MAAM,GAAG,CAAC,KAAK8F,KAAK,CAAClJ,IAAI,KAAK,OAAO,IAAIkJ,KAAK,CAAClJ,IAAI,KAAK,OAAO,CAAC;MACtF,IAAM+E,SAAS,GAAGvB,QAAQ,CAAC7C,MAAM,KAAKuI,KAAK,CAAClJ,IAAI,KAAK,MAAM,IAAIkJ,KAAK,CAAClJ,IAAI,KAAK,OAAO,CAAC;MACtF,IAAI,CAACoJ,OAAO,IAAIF,KAAK,CAAClJ,IAAI,KAAK,OAAO,IAAI,CAAC8E,OAAO,IAAI,CAACC,SAAS,EAAE;QAChEL,IAAI,CAAC;UAAE1E,IAAI,EAAE,MAAM;UAAER,KAAK,EAALA,KAAK;UAAEsB,MAAM,EAAE;QAAG,CAAC,CAAC;QACzC;MACF;;MAEA;MACA,OAAOyE,IAAI,CAACrB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,KAAK,EAAE;QACjC,IAAMoF,KAAK,GAAGnJ,KAAK,CAACyC,KAAK,CAACC,KAAK,GAAG,CAAC,CAAC;QACpC,IAAIyG,KAAK,IAAIA,KAAK,KAAK,GAAG,EAAE;UAC1B;QACF;QACA/D,IAAI,GAAGA,IAAI,CAACrB,KAAK,CAAC,CAAC,CAAC;QACpBC,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC;MACnB;MAEA,IAAI+E,KAAK,CAAClJ,IAAI,KAAK,KAAK,IAAI2D,GAAG,CAAC,CAAC,EAAE;QACjCD,IAAI,CAAC1D,IAAI,GAAG,UAAU;QACtB0D,IAAI,CAAClE,KAAK,IAAIA,KAAK;QACnBkE,IAAI,CAAC5C,MAAM,GAAGsB,QAAQ,CAAC/B,IAAI,CAAC;QAC5BuC,KAAK,CAAC9B,MAAM,GAAG4C,IAAI,CAAC5C,MAAM;QAC1B8B,KAAK,CAACR,QAAQ,GAAG,IAAI;QACrB+B,OAAO,CAAC3E,KAAK,CAAC;QACd;MACF;MAEA,IAAI0J,KAAK,CAAClJ,IAAI,KAAK,OAAO,IAAIkJ,KAAK,CAACxF,IAAI,CAAC1D,IAAI,KAAK,KAAK,IAAI,CAACqJ,SAAS,IAAI1F,GAAG,CAAC,CAAC,EAAE;QAC9Ef,KAAK,CAAC9B,MAAM,GAAG8B,KAAK,CAAC9B,MAAM,CAACoD,KAAK,CAAC,CAAC,EAAE,CAAC,CAACgF,KAAK,CAACpI,MAAM,GAAG4C,IAAI,CAAC5C,MAAM,EAAEH,MAAM,CAAC;QAC1EuI,KAAK,CAACpI,MAAM,SAAAxB,MAAA,CAAS4J,KAAK,CAACpI,MAAM,CAAE;QAEnC4C,IAAI,CAAC1D,IAAI,GAAG,UAAU;QACtB0D,IAAI,CAAC5C,MAAM,GAAGsB,QAAQ,CAAC/B,IAAI,CAAC,IAAIA,IAAI,CAACkJ,aAAa,GAAG,GAAG,GAAG,KAAK,CAAC;QACjE7F,IAAI,CAAClE,KAAK,IAAIA,KAAK;QACnBoD,KAAK,CAACR,QAAQ,GAAG,IAAI;QACrBQ,KAAK,CAAC9B,MAAM,IAAIoI,KAAK,CAACpI,MAAM,GAAG4C,IAAI,CAAC5C,MAAM;QAC1CqD,OAAO,CAAC3E,KAAK,CAAC;QACd;MACF;MAEA,IAAI0J,KAAK,CAAClJ,IAAI,KAAK,OAAO,IAAIkJ,KAAK,CAACxF,IAAI,CAAC1D,IAAI,KAAK,KAAK,IAAIuF,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC1E,IAAMiE,GAAG,GAAGjE,IAAI,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,GAAG,IAAI,GAAG,EAAE;QAE1C3C,KAAK,CAAC9B,MAAM,GAAG8B,KAAK,CAAC9B,MAAM,CAACoD,KAAK,CAAC,CAAC,EAAE,CAAC,CAACgF,KAAK,CAACpI,MAAM,GAAG4C,IAAI,CAAC5C,MAAM,EAAEH,MAAM,CAAC;QAC1EuI,KAAK,CAACpI,MAAM,SAAAxB,MAAA,CAAS4J,KAAK,CAACpI,MAAM,CAAE;QAEnC4C,IAAI,CAAC1D,IAAI,GAAG,UAAU;QACtB0D,IAAI,CAAC5C,MAAM,MAAAxB,MAAA,CAAM8C,QAAQ,CAAC/B,IAAI,CAAC,EAAAf,MAAA,CAAGoC,aAAa,OAAApC,MAAA,CAAIoC,aAAa,EAAApC,MAAA,CAAGkK,GAAG,MAAG;QACzE9F,IAAI,CAAClE,KAAK,IAAIA,KAAK;QAEnBoD,KAAK,CAAC9B,MAAM,IAAIoI,KAAK,CAACpI,MAAM,GAAG4C,IAAI,CAAC5C,MAAM;QAC1C8B,KAAK,CAACR,QAAQ,GAAG,IAAI;QAErB+B,OAAO,CAAC3E,KAAK,GAAGwE,OAAO,CAAC,CAAC,CAAC;QAE1BU,IAAI,CAAC;UAAE1E,IAAI,EAAE,OAAO;UAAER,KAAK,EAAE,GAAG;UAAEsB,MAAM,EAAE;QAAG,CAAC,CAAC;QAC/C;MACF;MAEA,IAAIoI,KAAK,CAAClJ,IAAI,KAAK,KAAK,IAAIuF,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC3C7B,IAAI,CAAC1D,IAAI,GAAG,UAAU;QACtB0D,IAAI,CAAClE,KAAK,IAAIA,KAAK;QACnBkE,IAAI,CAAC5C,MAAM,WAAAxB,MAAA,CAAWoC,aAAa,OAAApC,MAAA,CAAI8C,QAAQ,CAAC/B,IAAI,CAAC,EAAAf,MAAA,CAAGoC,aAAa,MAAG;QACxEkB,KAAK,CAAC9B,MAAM,GAAG4C,IAAI,CAAC5C,MAAM;QAC1B8B,KAAK,CAACR,QAAQ,GAAG,IAAI;QACrB+B,OAAO,CAAC3E,KAAK,GAAGwE,OAAO,CAAC,CAAC,CAAC;QAC1BU,IAAI,CAAC;UAAE1E,IAAI,EAAE,OAAO;UAAER,KAAK,EAAE,GAAG;UAAEsB,MAAM,EAAE;QAAG,CAAC,CAAC;QAC/C;MACF;;MAEA;MACA8B,KAAK,CAAC9B,MAAM,GAAG8B,KAAK,CAAC9B,MAAM,CAACoD,KAAK,CAAC,CAAC,EAAE,CAACR,IAAI,CAAC5C,MAAM,CAACH,MAAM,CAAC;;MAEzD;MACA+C,IAAI,CAAC1D,IAAI,GAAG,UAAU;MACtB0D,IAAI,CAAC5C,MAAM,GAAGsB,QAAQ,CAAC/B,IAAI,CAAC;MAC5BqD,IAAI,CAAClE,KAAK,IAAIA,KAAK;;MAEnB;MACAoD,KAAK,CAAC9B,MAAM,IAAI4C,IAAI,CAAC5C,MAAM;MAC3B8B,KAAK,CAACR,QAAQ,GAAG,IAAI;MACrB+B,OAAO,CAAC3E,KAAK,CAAC;MACd;IACF;IAEA,IAAM8E,KAAK,GAAG;MAAEtE,IAAI,EAAE,MAAM;MAAER,KAAK,EAALA,KAAK;MAAEsB,MAAM,EAAE0B;IAAK,CAAC;IAEnD,IAAInC,IAAI,CAACoC,IAAI,KAAK,IAAI,EAAE;MACtB6B,KAAK,CAACxD,MAAM,GAAG,KAAK;MACpB,IAAI4C,IAAI,CAAC1D,IAAI,KAAK,KAAK,IAAI0D,IAAI,CAAC1D,IAAI,KAAK,OAAO,EAAE;QAChDsE,KAAK,CAACxD,MAAM,GAAGwB,KAAK,GAAGgC,KAAK,CAACxD,MAAM;MACrC;MACA4D,IAAI,CAACJ,KAAK,CAAC;MACX;IACF;IAEA,IAAIZ,IAAI,KAAKA,IAAI,CAAC1D,IAAI,KAAK,SAAS,IAAI0D,IAAI,CAAC1D,IAAI,KAAK,OAAO,CAAC,IAAIK,IAAI,CAAC2I,KAAK,KAAK,IAAI,EAAE;MACrF1E,KAAK,CAACxD,MAAM,GAAGtB,KAAK;MACpBkF,IAAI,CAACJ,KAAK,CAAC;MACX;IACF;IAEA,IAAI1B,KAAK,CAACC,KAAK,KAAKD,KAAK,CAACE,KAAK,IAAIY,IAAI,CAAC1D,IAAI,KAAK,OAAO,IAAI0D,IAAI,CAAC1D,IAAI,KAAK,KAAK,EAAE;MAC/E,IAAI0D,IAAI,CAAC1D,IAAI,KAAK,KAAK,EAAE;QACvB4C,KAAK,CAAC9B,MAAM,IAAIgB,YAAY;QAC5B4B,IAAI,CAAC5C,MAAM,IAAIgB,YAAY;MAE7B,CAAC,MAAM,IAAIzB,IAAI,CAACgC,GAAG,KAAK,IAAI,EAAE;QAC5BO,KAAK,CAAC9B,MAAM,IAAIiB,aAAa;QAC7B2B,IAAI,CAAC5C,MAAM,IAAIiB,aAAa;MAE9B,CAAC,MAAM;QACLa,KAAK,CAAC9B,MAAM,IAAIwB,KAAK;QACrBoB,IAAI,CAAC5C,MAAM,IAAIwB,KAAK;MACtB;MAEA,IAAIsB,IAAI,CAAC,CAAC,KAAK,GAAG,EAAE;QAClBhB,KAAK,CAAC9B,MAAM,IAAIa,QAAQ;QACxB+B,IAAI,CAAC5C,MAAM,IAAIa,QAAQ;MACzB;IACF;IAEA+C,IAAI,CAACJ,KAAK,CAAC;EACb;EAEA,OAAO1B,KAAK,CAACO,QAAQ,GAAG,CAAC,EAAE;IACzB,IAAI9C,IAAI,CAAC6G,cAAc,KAAK,IAAI,EAAE,MAAM,IAAItG,WAAW,CAACb,WAAW,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;IACpF6C,KAAK,CAAC9B,MAAM,GAAGlC,KAAK,CAAC6K,UAAU,CAAC7G,KAAK,CAAC9B,MAAM,EAAE,GAAG,CAAC;IAClD6D,SAAS,CAAC,UAAU,CAAC;EACvB;EAEA,OAAO/B,KAAK,CAACS,MAAM,GAAG,CAAC,EAAE;IACvB,IAAIhD,IAAI,CAAC6G,cAAc,KAAK,IAAI,EAAE,MAAM,IAAItG,WAAW,CAACb,WAAW,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;IACpF6C,KAAK,CAAC9B,MAAM,GAAGlC,KAAK,CAAC6K,UAAU,CAAC7G,KAAK,CAAC9B,MAAM,EAAE,GAAG,CAAC;IAClD6D,SAAS,CAAC,QAAQ,CAAC;EACrB;EAEA,OAAO/B,KAAK,CAACQ,MAAM,GAAG,CAAC,EAAE;IACvB,IAAI/C,IAAI,CAAC6G,cAAc,KAAK,IAAI,EAAE,MAAM,IAAItG,WAAW,CAACb,WAAW,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;IACpF6C,KAAK,CAAC9B,MAAM,GAAGlC,KAAK,CAAC6K,UAAU,CAAC7G,KAAK,CAAC9B,MAAM,EAAE,GAAG,CAAC;IAClD6D,SAAS,CAAC,QAAQ,CAAC;EACrB;EAEA,IAAItE,IAAI,CAACkJ,aAAa,KAAK,IAAI,KAAK7F,IAAI,CAAC1D,IAAI,KAAK,MAAM,IAAI0D,IAAI,CAAC1D,IAAI,KAAK,SAAS,CAAC,EAAE;IACpF0E,IAAI,CAAC;MAAE1E,IAAI,EAAE,aAAa;MAAER,KAAK,EAAE,EAAE;MAAEsB,MAAM,KAAAxB,MAAA,CAAKoC,aAAa;IAAI,CAAC,CAAC;EACvE;;EAEA;EACA,IAAIkB,KAAK,CAACK,SAAS,KAAK,IAAI,EAAE;IAC5BL,KAAK,CAAC9B,MAAM,GAAG,EAAE;IAAC,IAAA4I,UAAA,GAAApL,0BAAA,CAEEsE,KAAK,CAAC5B,MAAM;MAAA2I,MAAA;IAAA;MAAhC,KAAAD,UAAA,CAAApB,CAAA,MAAAqB,MAAA,GAAAD,UAAA,CAAA7F,CAAA,IAAA0E,IAAA,GAAkC;QAAA,IAAvBjE,MAAK,GAAAqF,MAAA,CAAAnK,KAAA;QACdoD,KAAK,CAAC9B,MAAM,IAAIwD,MAAK,CAACxD,MAAM,IAAI,IAAI,GAAGwD,MAAK,CAACxD,MAAM,GAAGwD,MAAK,CAAC9E,KAAK;QAEjE,IAAI8E,MAAK,CAACsF,MAAM,EAAE;UAChBhH,KAAK,CAAC9B,MAAM,IAAIwD,MAAK,CAACsF,MAAM;QAC9B;MACF;IAAC,SAAAnB,GAAA;MAAAiB,UAAA,CAAAhB,CAAA,CAAAD,GAAA;IAAA;MAAAiB,UAAA,CAAAf,CAAA;IAAA;EACH;EAEA,OAAO/F,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA1C,KAAK,CAAC0F,SAAS,GAAG,UAACzF,KAAK,EAAEf,OAAO,EAAK;EACpC,IAAMiB,IAAI,GAAA5B,aAAA,KAAQW,OAAO,CAAE;EAC3B,IAAMkB,GAAG,GAAG,OAAOD,IAAI,CAACE,SAAS,KAAK,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAAC5B,UAAU,EAAEwB,IAAI,CAACE,SAAS,CAAC,GAAG1B,UAAU;EAClG,IAAM6B,GAAG,GAAGP,KAAK,CAACQ,MAAM;EACxB,IAAID,GAAG,GAAGJ,GAAG,EAAE;IACb,MAAM,IAAIM,WAAW,kBAAAtB,MAAA,CAAkBoB,GAAG,wCAAApB,MAAA,CAAqCgB,GAAG,CAAE,CAAC;EACvF;EAEAH,KAAK,GAAGlB,YAAY,CAACkB,KAAK,CAAC,IAAIA,KAAK;EACpC,IAAMe,KAAK,GAAGtC,KAAK,CAACuC,SAAS,CAAC/B,OAAO,CAAC;;EAEtC;EACA,IAAAyK,oBAAA,GAUIlL,SAAS,CAAC0C,SAAS,CAACH,KAAK,CAAC;IAT5BM,WAAW,GAAAqI,oBAAA,CAAXrI,WAAW;IACXE,aAAa,GAAAmI,oBAAA,CAAbnI,aAAa;IACbC,QAAQ,GAAAkI,oBAAA,CAARlI,QAAQ;IACRC,UAAU,GAAAiI,oBAAA,CAAVjI,UAAU;IACVC,MAAM,GAAAgI,oBAAA,CAANhI,MAAM;IACNiI,OAAO,GAAAD,oBAAA,CAAPC,OAAO;IACP/H,aAAa,GAAA8H,oBAAA,CAAb9H,aAAa;IACbG,IAAI,GAAA2H,oBAAA,CAAJ3H,IAAI;IACJC,YAAY,GAAA0H,oBAAA,CAAZ1H,YAAY;EAGd,IAAMG,KAAK,GAAGjC,IAAI,CAACgC,GAAG,GAAGyH,OAAO,GAAGjI,MAAM;EACzC,IAAMkI,QAAQ,GAAG1J,IAAI,CAACgC,GAAG,GAAGN,aAAa,GAAGF,MAAM;EAClD,IAAMZ,OAAO,GAAGZ,IAAI,CAACY,OAAO,GAAG,EAAE,GAAG,IAAI;EACxC,IAAM2B,KAAK,GAAG;IAAEM,OAAO,EAAE,KAAK;IAAEF,MAAM,EAAE;EAAG,CAAC;EAC5C,IAAIR,IAAI,GAAGnC,IAAI,CAACoC,IAAI,KAAK,IAAI,GAAG,KAAK,GAAGP,IAAI;EAE5C,IAAI7B,IAAI,CAACY,OAAO,EAAE;IAChBuB,IAAI,OAAAlD,MAAA,CAAOkD,IAAI,MAAG;EACpB;EAEA,IAAMJ,QAAQ,GAAG,SAAXA,QAAQA,CAAG/B,IAAI,EAAI;IACvB,IAAIA,IAAI,CAAC4I,UAAU,KAAK,IAAI,EAAE,OAAOzG,IAAI;IACzC,WAAAlD,MAAA,CAAW2B,OAAO,YAAA3B,MAAA,CAAS6C,YAAY,EAAA7C,MAAA,CAAGe,IAAI,CAACgC,GAAG,GAAGT,UAAU,GAAGJ,WAAW;EAC/E,CAAC;EAED,IAAMwI,MAAM,GAAG,SAATA,MAAMA,CAAGC,GAAG,EAAI;IACpB,QAAQA,GAAG;MACT,KAAK,GAAG;QACN,UAAA3K,MAAA,CAAUgD,KAAK,EAAAhD,MAAA,CAAGqC,QAAQ,EAAArC,MAAA,CAAGkD,IAAI;MAEnC,KAAK,IAAI;QACP,UAAAlD,MAAA,CAAUkC,WAAW,EAAAlC,MAAA,CAAGqC,QAAQ,EAAArC,MAAA,CAAGkD,IAAI;MAEzC,KAAK,KAAK;QACR,UAAAlD,MAAA,CAAUgD,KAAK,EAAAhD,MAAA,CAAGkD,IAAI,EAAAlD,MAAA,CAAGkC,WAAW,EAAAlC,MAAA,CAAGqC,QAAQ,EAAArC,MAAA,CAAGkD,IAAI;MAExD,KAAK,KAAK;QACR,UAAAlD,MAAA,CAAUgD,KAAK,EAAAhD,MAAA,CAAGkD,IAAI,EAAAlD,MAAA,CAAGoC,aAAa,EAAApC,MAAA,CAAGqC,QAAQ,EAAArC,MAAA,CAAGyK,QAAQ,EAAAzK,MAAA,CAAGkD,IAAI;MAErE,KAAK,IAAI;QACP,OAAOF,KAAK,GAAGF,QAAQ,CAAC/B,IAAI,CAAC;MAE/B,KAAK,MAAM;QACT,aAAAf,MAAA,CAAagD,KAAK,EAAAhD,MAAA,CAAG8C,QAAQ,CAAC/B,IAAI,CAAC,EAAAf,MAAA,CAAGoC,aAAa,QAAApC,MAAA,CAAKyK,QAAQ,EAAAzK,MAAA,CAAGqC,QAAQ,EAAArC,MAAA,CAAGkD,IAAI;MAEpF,KAAK,QAAQ;QACX,aAAAlD,MAAA,CAAagD,KAAK,EAAAhD,MAAA,CAAG8C,QAAQ,CAAC/B,IAAI,CAAC,EAAAf,MAAA,CAAGoC,aAAa,QAAApC,MAAA,CAAKyK,QAAQ,EAAAzK,MAAA,CAAGkD,IAAI,EAAAlD,MAAA,CAAGkC,WAAW,EAAAlC,MAAA,CAAGqC,QAAQ,EAAArC,MAAA,CAAGkD,IAAI;MAEzG,KAAK,OAAO;QACV,aAAAlD,MAAA,CAAagD,KAAK,EAAAhD,MAAA,CAAG8C,QAAQ,CAAC/B,IAAI,CAAC,EAAAf,MAAA,CAAGoC,aAAa,QAAApC,MAAA,CAAKkC,WAAW,EAAAlC,MAAA,CAAGqC,QAAQ,EAAArC,MAAA,CAAGkD,IAAI;MAEvF;QAAS;UACP,IAAMiE,KAAK,GAAG,gBAAgB,CAACC,IAAI,CAACuD,GAAG,CAAC;UACxC,IAAI,CAACxD,KAAK,EAAE;UAEZ,IAAMyD,OAAM,GAAGF,MAAM,CAACvD,KAAK,CAAC,CAAC,CAAC,CAAC;UAC/B,IAAI,CAACyD,OAAM,EAAE;UAEb,OAAOA,OAAM,GAAG1I,WAAW,GAAGiF,KAAK,CAAC,CAAC,CAAC;QACxC;IACF;EACF,CAAC;EAED,IAAM3F,MAAM,GAAGlC,KAAK,CAAC2E,YAAY,CAACpD,KAAK,EAAEyC,KAAK,CAAC;EAC/C,IAAIsH,MAAM,GAAGF,MAAM,CAAClJ,MAAM,CAAC;EAE3B,IAAIoJ,MAAM,IAAI7J,IAAI,CAACkJ,aAAa,KAAK,IAAI,EAAE;IACzCW,MAAM,OAAA5K,MAAA,CAAOoC,aAAa,MAAG;EAC/B;EAEA,OAAOwI,MAAM;AACf,CAAC;AAEDC,MAAM,CAACC,OAAO,GAAGlK,KAAK"},"metadata":{},"sourceType":"script"}