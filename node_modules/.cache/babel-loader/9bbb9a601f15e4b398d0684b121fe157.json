{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = globsToMatcher;\nfunction _micromatch() {\n  var data = _interopRequireDefault(require('micromatch'));\n  _micromatch = function _micromatch() {\n    return data;\n  };\n  return data;\n}\nvar _replacePathSepForGlob = _interopRequireDefault(require('./replacePathSepForGlob'));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar globsToMatchersMap = new Map();\nvar micromatchOptions = {\n  dot: true\n};\n/**\n * Converts a list of globs into a function that matches a path against the\n * globs.\n *\n * Every time micromatch is called, it will parse the glob strings and turn\n * them into regexp instances. Instead of calling micromatch repeatedly with\n * the same globs, we can use this function which will build the micromatch\n * matchers ahead of time and then have an optimized path for determining\n * whether an individual path matches.\n *\n * This function is intended to match the behavior of `micromatch()`.\n *\n * @example\n * const isMatch = globsToMatcher(['*.js', '!*.test.js']);\n * isMatch('pizza.js'); // true\n * isMatch('pizza.test.js'); // false\n */\n\nfunction globsToMatcher(globs) {\n  if (globs.length === 0) {\n    // Since there were no globs given, we can simply have a fast path here and\n    // return with a very simple function.\n    return function () {\n      return false;\n    };\n  }\n  var matchers = globs.map(function (glob) {\n    if (!globsToMatchersMap.has(glob)) {\n      // Matchers that are negated have different behavior than matchers that\n      // are not negated, so we need to store this information ahead of time.\n      var _micromatch$default$s = _micromatch().default.scan(glob, micromatchOptions),\n        negated = _micromatch$default$s.negated;\n      var matcher = {\n        isMatch: _micromatch().default.matcher(glob, micromatchOptions),\n        negated: negated\n      };\n      globsToMatchersMap.set(glob, matcher);\n    }\n    return globsToMatchersMap.get(glob);\n  });\n  return function (path) {\n    var replacedPath = (0, _replacePathSepForGlob.default)(path);\n    var kept = undefined;\n    var negatives = 0;\n    for (var i = 0; i < matchers.length; i++) {\n      var _matchers$i = matchers[i],\n        isMatch = _matchers$i.isMatch,\n        negated = _matchers$i.negated;\n      if (negated) {\n        negatives++;\n      }\n      var matched = isMatch(replacedPath);\n      if (!matched && negated) {\n        // The path was not matched, and the matcher is a negated matcher, so we\n        // want to omit the path. This means that the negative matcher is\n        // filtering the path out.\n        kept = false;\n      } else if (matched && !negated) {\n        // The path was matched, and the matcher is not a negated matcher, so we\n        // want to keep the path.\n        kept = true;\n      }\n    } // If all of the globs were negative globs, then we want to include the path\n    // as long as it was not explicitly not kept. Otherwise only include\n    // the path if it was kept. This allows sets of globs that are all negated\n    // to allow some paths to be matched, while sets of globs that are mixed\n    // negated and non-negated to cause the negated matchers to only omit paths\n    // and not keep them.\n\n    return negatives === matchers.length ? kept !== false : !!kept;\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","globsToMatcher","_micromatch","data","_interopRequireDefault","require","_replacePathSepForGlob","obj","__esModule","globsToMatchersMap","Map","micromatchOptions","dot","globs","length","matchers","map","glob","has","_micromatch$default$s","scan","negated","matcher","isMatch","set","get","path","replacedPath","kept","undefined","negatives","i","_matchers$i","matched"],"sources":["/home/ugaly/Desktop/semister 2/react-scheduler-demo-standard/node_modules/jest-util/build/globsToMatcher.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = globsToMatcher;\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _replacePathSepForGlob = _interopRequireDefault(\n  require('./replacePathSepForGlob')\n);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst globsToMatchersMap = new Map();\nconst micromatchOptions = {\n  dot: true\n};\n/**\n * Converts a list of globs into a function that matches a path against the\n * globs.\n *\n * Every time micromatch is called, it will parse the glob strings and turn\n * them into regexp instances. Instead of calling micromatch repeatedly with\n * the same globs, we can use this function which will build the micromatch\n * matchers ahead of time and then have an optimized path for determining\n * whether an individual path matches.\n *\n * This function is intended to match the behavior of `micromatch()`.\n *\n * @example\n * const isMatch = globsToMatcher(['*.js', '!*.test.js']);\n * isMatch('pizza.js'); // true\n * isMatch('pizza.test.js'); // false\n */\n\nfunction globsToMatcher(globs) {\n  if (globs.length === 0) {\n    // Since there were no globs given, we can simply have a fast path here and\n    // return with a very simple function.\n    return () => false;\n  }\n\n  const matchers = globs.map(glob => {\n    if (!globsToMatchersMap.has(glob)) {\n      // Matchers that are negated have different behavior than matchers that\n      // are not negated, so we need to store this information ahead of time.\n      const {negated} = _micromatch().default.scan(glob, micromatchOptions);\n\n      const matcher = {\n        isMatch: _micromatch().default.matcher(glob, micromatchOptions),\n        negated\n      };\n      globsToMatchersMap.set(glob, matcher);\n    }\n\n    return globsToMatchersMap.get(glob);\n  });\n  return path => {\n    const replacedPath = (0, _replacePathSepForGlob.default)(path);\n    let kept = undefined;\n    let negatives = 0;\n\n    for (let i = 0; i < matchers.length; i++) {\n      const {isMatch, negated} = matchers[i];\n\n      if (negated) {\n        negatives++;\n      }\n\n      const matched = isMatch(replacedPath);\n\n      if (!matched && negated) {\n        // The path was not matched, and the matcher is a negated matcher, so we\n        // want to omit the path. This means that the negative matcher is\n        // filtering the path out.\n        kept = false;\n      } else if (matched && !negated) {\n        // The path was matched, and the matcher is not a negated matcher, so we\n        // want to keep the path.\n        kept = true;\n      }\n    } // If all of the globs were negative globs, then we want to include the path\n    // as long as it was not explicitly not kept. Otherwise only include\n    // the path if it was kept. This allows sets of globs that are all negated\n    // to allow some paths to be matched, while sets of globs that are mixed\n    // negated and non-negated to cause the negated matchers to only omit paths\n    // and not keep them.\n\n    return negatives === matchers.length ? kept !== false : !!kept;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}